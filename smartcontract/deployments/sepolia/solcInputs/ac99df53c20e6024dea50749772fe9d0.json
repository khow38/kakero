{
  "language": "Solidity",
  "sources": {
    "contracts/BinaryBet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n/* Errors */\nerror Betting__ExecuteNotNeeded(uint256 currentBalance, uint256 numPlayers, bool gameFinished);\nerror Betting__TransferFailed();\nerror Betting__BettingNotOpen();\n\n/**@title A sample Betting Contract\n * @author Yakou Hikoichi\n * * @notice This contract is for creating a sample betting contract\n*/\ncontract Betting {\n\n    // Betting Variables\n    uint256 private minimumBet;\n    uint256 private totalBetOne;\n    uint256 private totalBetTwo;\n    uint256 private startTimestamp;\n    uint256 private matchDateTimestamp;\n\n    address payable private owner;\n    address private admin;\n    bool public gameFinished;\n\n    string public gameDescription;\n\n    string private option1Name;\n    string private option2Name;\n    string private option1LeagueName;\n    string private option2LeagueName;\n\n    struct Player {\n        uint256 amountBet;\n        uint16 teamSelected;\n    }\n    // Address of the player and => the user info\n    mapping(address => Player) public playerInfo;\n    address payable[] public players;\n    address payable[] private winners;\n\n    uint private commission = 5;\n\n    /* Events */\n    event BettingEnter(address indexed player);\n\n    /* Functions */\n    constructor(\n      string memory _gameDescription,\n      string memory _option1Name,\n      string memory _option2Name,\n      string memory _option1LeagueName,\n      string memory _option2LeagueName,\n      uint256 _matchDateTimestamp,\n      uint256 entranceFee\n    ) {\n        minimumBet = entranceFee;         // 0.01 etherium\n        gameFinished = false;\n        startTimestamp = block.timestamp;\n        matchDateTimestamp = _matchDateTimestamp;\n        admin = msg.sender;\n        gameDescription = _gameDescription;\n        option1Name = _option1Name;\n        option2Name = _option2Name;\n        option1LeagueName = _option1LeagueName;\n        option2LeagueName = _option2LeagueName;\n        owner = payable(admin);\n    }\n\n    function betOnOption1() public payable {\n        //The first require is used to check if the player already exist\n        require(!checkPlayerExists(msg.sender));\n        require(!gameFinished);\n        require(msg.value >= minimumBet, \"Insufficient bet amount\");\n        //We set the player informations : amount of the bet and selected team\n        playerInfo[msg.sender].amountBet = msg.value;\n        playerInfo[msg.sender].teamSelected = 1;\n\n        //then we add the address of the player to the players array\n        players.push(payable(msg.sender));\n\n        //at the end, we increment the stakes of the team selected with the player bet\n        totalBetOne += (msg.value * (100 - commission)/100);\n        emit BettingEnter(msg.sender);\n    }\n\n    function betOnOption2() public payable {\n        //The first require is used to check if the player already exist\n        require(!checkPlayerExists(msg.sender));\n        require(!gameFinished);\n        require(msg.value >= minimumBet, \"Insufficient bet amount\");\n        //We set the player informations : amount of the bet and selected team\n        playerInfo[msg.sender].amountBet = msg.value;\n        playerInfo[msg.sender].teamSelected = 2;\n\n        //then we add the address of the player to the players array\n        players.push(payable(msg.sender));\n\n        //at the end, we increment the stakes of the team selected with the player bet\n        totalBetTwo += (msg.value * (100 - commission)/100);\n        emit BettingEnter(msg.sender);\n    }\n\n    function distributePrizes(uint16 teamWinner) internal onlyAdmin {\n\n        uint256 LoserBet = 0; //This will take the value of all losers bet\n        uint256 WinnerBet = 0; //This will take the value of all winners bet\n        address add;\n        uint256 bet;\n        address payable playerAddress;\n        //We loop through the player array to check who selected the winner team\n        for(uint256 i = 0; i < players.length; i++){\n            playerAddress = players[i];\n            //If the player selected the winner team\n            //We add his address to the winners array\n            if(playerInfo[playerAddress].teamSelected == teamWinner){\n                winners.push(playerAddress);\n            }\n        }\n        //We define which bet sum is the Loser one and which one is the winner\n        if (teamWinner == 1){\n            LoserBet = totalBetTwo;\n            WinnerBet = totalBetOne;\n        }\n        else{\n            LoserBet = totalBetOne;\n            WinnerBet = totalBetTwo;\n        }\n        //We loop through the array of winners, to give ethers to the winners\n        for(uint256 j = 0; j < winners.length; j++){\n            add = winners[j];\n            bet = playerInfo[add].amountBet;\n            uint256 prize = (bet*(10000+(LoserBet*10000/WinnerBet)))/10000;\n            //Transfer the money to the user\n            payable(winners[j]).transfer(prize);\n        }\n        owner.transfer(address(this).balance);\n\n        gameFinished = true;\n        // Delete all the players\n        for (uint256 i = 0; i < players.length; i++){\n            delete playerInfo[players[i]];\n        }\n        delete players; // Delete all the players array\n        delete winners; // Delete all the winners array\n        // players.length = 0; // Delete all the players array\n        LoserBet = 0; //reinitialize the bets\n        WinnerBet = 0;\n        totalBetOne = 0;\n        totalBetTwo = 0;\n    }\n\n    /**\n     * @dev This is the function whether the execution of betting is ready or not\n     * they look for `readyToExecute` to return True.\n     * the following should be true for this to return true:\n     * 1. The time interval has passed between betting runs.\n     * 2. The Game is open.\n     * 3. The contract has ETH.\n     */\n    function checkExecuteReady()\n        public\n        view\n        returns (\n            bool readyToExecute,\n            bytes memory /* performData */\n        )\n    {\n        bool isOpen = gameFinished == false;\n        bool timePassed = ((block.timestamp - matchDateTimestamp) > 0);\n        bool hasPlayers = players.length > 0;\n        bool hasBalance = address(this).balance > 0;\n        readyToExecute = (timePassed && isOpen && hasBalance && hasPlayers);\n        return (readyToExecute, \"0x0\"); // can we comment this out?\n    }\n\n    /**\n     * @dev Once `checkExecuteReady` is returning `true`, this function is called\n     * and it kicks off the winner.\n     */\n    function performExecute(\n        uint16 oraclemsg\n    ) external onlyAdmin{\n        (bool readyToExecute, ) = checkExecuteReady();\n        // require(upkeepNeeded, \"Upkeep not needed\");\n        if (!readyToExecute) {\n            revert Betting__ExecuteNotNeeded(\n                address(this).balance,\n                players.length,\n                gameFinished\n            );\n        }\n        // oracle engaged and redistribution of asset happens\n        distributePrizes(oraclemsg);\n    }\n\n\n    /** Getter Functions */\n\n    function getAdmin() public view returns (address) {\n        return admin;\n    }\n\n    function reopenGame( string memory _gameDescription\n                       , string memory _option1Name\n                       , string memory _option1LeagueName\n                       , string memory _option2Name\n                       , string memory _option2LeagueName\n                       , uint256 _matchDateTimestamp) public onlyAdmin{\n        gameFinished = false;\n        gameDescription = _gameDescription;\n        option1Name = _option1Name;\n        option1LeagueName = _option1LeagueName;\n        option2Name = _option2Name;\n        option2LeagueName = _option2LeagueName;\n        matchDateTimestamp = _matchDateTimestamp;\n        players = new address payable [](0);\n        startTimestamp = block.timestamp;\n    }\n\n    function getGameFinished() public view returns (bool) {\n        return gameFinished;\n    }\n\n    function checkPlayerExists(address player) public view returns (bool) {\n      uint256 l = players.length;\n      for(uint256 i = 0; i < l; i++){\n         if(players[i] == player) return true;\n      }\n      return false;\n    }\n\n    function AmountOne() public view returns(uint256){\n       return totalBetOne;\n    }\n\n    function getOption1Name() public view returns(string memory){\n       return option1Name;\n    }\n\n    function getOption1LeagueName() public view returns(string memory){\n       return option1LeagueName;\n    }\n\n    function AmountTwo() public view returns(uint256){\n       return totalBetTwo;\n    }\n\n    function getOption2Name() public view returns(string memory){\n       return option2Name;\n    }\n\n    function getOption2LeagueName() public view returns(string memory){\n       return option2LeagueName;\n    }\n\n    function getNumberOfPlayers() public view returns (uint256) {\n        return players.length;\n    }\n\n    function getMatchDateTimestamp() public view returns (uint256) {\n        return matchDateTimestamp;\n    }\n\n    function getStartTimestamp() public view returns (uint256) {\n        return startTimestamp;\n    }\n\n    function getPlayerInfo(uint256 index) public view returns (address) {\n        return players[index];\n    }\n\n    function getEntranceFee() public view returns (uint256) {\n        return minimumBet;\n    }\n\n    function getCommissionRatio() public view returns (uint256) {\n        return commission;\n    }\n\n    modifier onlyAdmin {\n        require(msg.sender == admin, \"Only admin can call this function\");\n        _;\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}